#!/usr/bin/python3

# Copyright: 2016-2017 Dmitry Shachnev <mitya57@debian.org>
#            2018-2019 Kai Pastor
# License: LGPL-3 or GPL-2+
#
# License: LGPL-3
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License version 3
# as published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# On Debian systems, the complete text of the GNU Lesser General Public
# License version 3 can be found in /usr/share/common-licenses/LGPL-3.
#
# License: GPL-2
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# On Debian systems, the complete text of the GNU General Public
# License version 2 can be found in /usr/share/common-licenses/GPL-2.


import json
import os
import re
import sys

verbose = 'VERBOSE' in os.environ

default_authors = ( (2018, 2018, 'The Qt Company Ltd.'), )

author_map = {
    re.compile('^BlackBerry|^Research [Ii]n Motion'): 'BlackBerry Limited (formerly Research In Motion)',
    re.compile('^BogDan Vatra'): 'BogDan Vatra',
    re.compile('^Canonical'): 'Canonical, Ltd.',
    re.compile('^David Faure'): 'David Faure',
    re.compile('^Giuseppe D\'Angelo'): 'Giuseppe D\'Angelo <dangelog@gmail.com>',
    re.compile('^Governikus GmbH & Co. KG'): 'Governikus GmbH & Co. KG',
    re.compile('^Green Hills Software'): 'Green Hills Software',
    re.compile('^Intel Corporation'): 'Intel Corporation',
    re.compile('^Ivan Komissarov'): 'Ivan Komissarov <ABBAPOH@gmail.com>',
    re.compile('KDAB'): 'Klarälvdalens Datakonsult AB, a KDAB Group company',
    re.compile('^Konstantin Ritt'): 'Konstantin Ritt',
    re.compile('^Lorn Potter'): 'Lorn Potter',
    re.compile('Martsum .*tmartsum\[at\]gmail.com'): 'Thorbjørn Lund Martsum <tmartsum@gmail.com>',
    re.compile('^Olivier Goffart'): 'Olivier Goffart <ogoffart@woboq.com>',
    re.compile('^Richard J. Moore'): 'Richard J. Moore <rich@kde.org>',
    re.compile('^Robin Burchell'): 'Robin Burchell <robin.burchell@viroteck.net>',
    re.compile('^Samuel Gaist'): 'Samuel Gaist <samuel.gaist@edeltech.ch>',
    re.compile('^Stephen Kelly'): 'Stephen Kelly <steveire@gmail.com>',
    re.compile('^The Qt Company'): 'The Qt Company Ltd.',
}

licenses_map = {
    'BSD': 'BSD-3-clause',
    'FDL': 'GFDL-NIV-1.3',
    'GPL': 'GPL-3',
    'GPL-EXCEPT': 'GPL-3 with Qt-1.0 exception',
    'LGPL': 'LGPL-3 or GPL-2',
    'LGPL3': 'LGPL-3 or GPL-2', # Legacy, used in Qt Location
    'MIT': 'MIT',
}

exclude_prefixes = (
    re.compile('^\.git'),
    re.compile('^header'),
    re.compile('^examples/'),
    re.compile('^tests/'),
    re.compile('^.*/snippets/'),
    re.compile('^(?!src/assistant/assistant/doc).*\.qdoc'),
)

exclude_modules = (
    'qttestlib',
    'somemodule',
)

start_header = '## BEGIN AUTO GENERATED BLOCK'
start_patterns = '# Filepath patterns'
start_overrides = '# Per-file overrides'
start_attribution = '# Qt 3rd-party attribution'
end_header = '## END AUTO GENERATED BLOCK'


# A representation of a single entry in the 'Files' field of a files paragraph.
class PatternInfo():
    def __init__(self, path):
        self.path = path
        self.regex = re.compile('^' + re.escape(path).replace('\\*', '.*') + '$')
        self.count = 0

    def match(self, filepath):
        return self.regex.match(filepath)


# A representation of a 'Files' field together with their 'Copyright'
class CopyrightInfo():
    def __init__(self):
        self.min_years = {}
        self.max_years = {}
        self.authors = []
        self.files = []
        self.debian_copyright = None

    def add_authors(self, authors):
        for min_year, max_year, author in authors:
            if author in self.authors:
                self.min_years[author] = min(self.min_years[author], min_year)
                self.max_years[author] = max(self.max_years[author], max_year)
            else:
                self.authors.append(author)
                self.min_years[author] = min_year
                self.max_years[author] = max_year

    def get_strings(self, authors):
        for author in authors:
            min_year = self.min_years[author]
            max_year = self.max_years[author]
            if min_year == max_year:
                yield '%d %s' % (min_year, author)
            else:
                yield '%d-%d %s' % (min_year, max_year, author)


def canonicalize_author_name(author):
    for regex, replacement in author_map.items():
        if regex.search(author):
            return replacement
    return author


def parse_file(filename):
    license = None
    authors = []
    with open(filename) as file:
        try:
            data = file.readlines(500)
        except UnicodeDecodeError:
            data = []
            authors = None
    for line in data:
        if line.startswith(' ** '): # qtandroidextras quirk
            line = line[1:]
        if line.startswith('.\\" '): # qttools manual pages
            line = line[1:]
        if line[3:16] == 'Copyright (C)' and line[0] != ' ':
            copyright = line[17:-1]
            max_year = min_year = int(copyright[:4])
            if copyright[4] == '-':
                max_year = int(copyright[5:9])
                author = copyright[10:]
            elif copyright[4:7] == ' - ':
                max_year = int(copyright[7:11])
                author = copyright[12:]
            else:
                author = copyright[5:]
            author = canonicalize_author_name(author)
            authors.append((min_year, max_year, author))
        if line[3:21] == '$QT_BEGIN_LICENSE:':
            license = licenses_map[line[21:-2]]
        elif license is None and '$QT_BEGIN_LICENSE:' in line:
            license = 'QT_BEGIN_LICENSE' # Error, handled validate_license
    if license and not authors and not license == 'QT_BEGIN_LICENSE':
        print(filename + ' : ' + license + ' : No authors!', file=sys.stderr)
    elif verbose:
        if authors is None:
            print(filename + ' (binary)')
        elif license is None:
            print(filename + ' (unknown)')
        else:
            print(filename + '(' + license + ')')
    return license, authors


def get_source_files(root_directory):
    for dirpath, dirnames, filenames in os.walk(root_directory):
        for filename in filenames:
            full_path = os.path.join(dirpath, filename)
            if full_path.startswith('./'):
                full_path = full_path[2:]
            if any(prefix.match(full_path) for prefix in exclude_prefixes):
                continue
            yield full_path


def format_list(title, strings):
    return title + ('\n' + ' ' * len(title)).join(strings)


def main(root_directory):
    with open('debian/copyright') as copyright_file:
        current_copyright = copyright_file.read()
        start_pos = current_copyright.find(start_header) + len(start_header) + 1
        start_data = current_copyright[:start_pos]
        end_pos = current_copyright.find(end_header) - 1
        end_data = current_copyright[end_pos:]

    known_patterns = read_patterns(current_copyright[start_pos:end_pos])
    data = read_input(root_directory, known_patterns)
    attribution = read_attribution(root_directory)
    end_data = validate_licenses(known_patterns, data, end_data)

    with open('debian/copyright', 'w') as output_file:
        output_file.write(start_data)
        write_output(known_patterns, data, attribution, output_file)
        output_file.write(end_data)


# Read patterns from Debian copyright "Files paragraphs"
def read_patterns(paragraphs):
    known_patterns = []
    files = ''
    copyright = []
    for line in paragraphs.splitlines():
        if line == '':
            continue
        elif line.startswith(start_overrides):
            break
        elif line.startswith(start_attribution):
            break
        elif line.startswith('Copyright: '):
            copyright.append(line[11:])
        elif line.startswith('           '):
            copyright.append(line[11:])
        elif line.startswith('Files: '):
            files = line[7:]
        elif line.startswith('       '):
            files += line[6:]
        elif line.startswith('License: '):
            files = files.strip()
            patterns = list(filter(lambda x: '*' in x, files.split()))
            if patterns:
                info = CopyrightInfo()
                info.license = line[9:].strip()
                info.patterns = list(map(PatternInfo, patterns))
                if files == '*':
                    info.add_authors(default_authors)
                elif files == 'debian/*':
                    info.debian_copyright = copyright
                known_patterns.append(info)
            files = ''
            copyright = []
    return known_patterns


# Find the known "Files paragraphs" for a filename
def find_pattern(known_patterns, filename, license, authors):
    is_default_authorship = len(authors) == 1 and authors[0][2] == default_authors[0][2]
    matching_info = None
    matching_pattern = None
    for info in known_patterns:
        pattern = next(filter(lambda p: p.regex.fullmatch(filename), info.patterns), None)
        if pattern:
            if info.license == license and (pattern.path != '*' or is_default_authorship):
                matching_info = info
                matching_pattern = pattern
            else:
                matching_info = None
                matching_pattern = None
    if matching_info:
        return (matching_info, matching_pattern)
    return (None, None)


def read_input(root_directory, known_patterns):
    data = {}

    for filename in get_source_files(root_directory):
        license, authors = parse_file(filename)
        if license is None:
            continue
        (matching_info, matching_pattern) = find_pattern(known_patterns, filename, license, authors)
        if matching_info:
            matching_info.add_authors(authors)
            matching_pattern.count += 1
        else:
            if license not in data:
               data[license] = CopyrightInfo()
            copyright_info = data[license]
            copyright_info.files.append(filename)
            copyright_info.add_authors(authors)
    return data


def read_attribution(root_directory):
    data = []
    canonical_root = os.path.realpath(root_directory)
    with open('debian/attribution.json') as attribution_file:
        attribution = json.load(attribution_file)
        for item in attribution:
            if item['QDocModule'] in exclude_modules:
                continue
            copyright_info = CopyrightInfo()
            license = item['LicenseId'].replace('Clause', 'clause').replace(' WITH ', ' with ')
            if item['LicenseId'] in ('', 'NONE'):
                license = item['Id']
            if item['LicenseId'] in ('', 'NONE', 'Public Domain'):
                license = 'public-domain'
            else:
                licenses = []
                for l1 in license.split(' OR '):
                    licenses2 = []
                    for l2 in l1.split(' AND '):
                        if l2.lower() != item['Id']:
                            l2 = '{0} ({1})'.format(l2, item['Id'])
                        licenses2.append(l2)
                    licenses.append(' and '.join(licenses2))
                license = ' or '.join(licenses)
            if item['LicenseFile']:
                with open(item['LicenseFile']) as license_file:
                    for line in license_file.read().rstrip().splitlines():
                        line = line.rstrip()
                        if line == '':
                            license += '\n .'
                        else:
                            license += '\n ' + line
            copyright_info.license = license

            path = os.path.relpath(item['Path'], canonical_root)
            files = item['Files']
            if os.path.isfile(path):
                copyright_info.files.append(path)
            elif files:
                for file in files.split(' '):
                    copyright_info.files.append(path + '/' + file)
            else:
                copyright_info.files.append(path + '/*')
            
            for author in item['Copyright'].splitlines():
                author = author.replace('Copyright ','')
                author = author.replace('(C)','')
                author = author.replace('(c)','')
                author = author.replace('©','')
                author = author.strip()
                if not author == '':
                    copyright_info.authors.append(author)

            data.append(copyright_info)

    return data


def validate_licenses(known_patterns, data, end_data):
    errors = 0
    used_licenses = []

    for copyright_info in filter(lambda c: not c.debian_copyright, known_patterns):
        for pattern in copyright_info.patterns:
            if pattern.count == 0:
                print('update-copyright: warning: no matching files for ' + pattern.path, file=sys.stderr)

    for copyright_info in known_patterns:
        if next(filter(lambda p: p.count > 0 or p.path == '*', copyright_info.patterns), None):
            for l1 in copyright_info.license.split(' or '):
                for l2 in l1.split(' and '):
                    license_line = "License: " + l2
                    if not license_line in end_data:
                        print('update-copyright: error: Undefined license ' + l2 + format_list(' in  ', map(lambda p: p.path, copyright_info.patterns)), file=sys.stderr)
                        errors += 1
                    elif not license_line in used_licenses:
                        used_licenses.append(license_line)

    for license in data.keys():
        if license == 'QT_BEGIN_LICENSE':
            print('update-copyright: error: unhandled QT_BEGIN_LICENSE' + format_list(' in ',data[license].files), file=sys.stderr)
            errors += 1
            continue
        for l1 in license.split(' or '):
            for l2 in l1.split(' and '):
                license_line = "License: " + l2
                if not license_line in end_data:
                    print('update-copyright: error: Undefined license ' + l2 + format_list(' in  ', data[license].files), file=sys.stderr)
                    errors += 1
                elif not license_line in used_licenses:
                    used_licenses.append(license_line)

    remainder = []
    license_line = None
    skip_body = False
    for line in end_data.splitlines():
        if line == '':
            skip_body = False
            if remainder and remainder[-1] == '':
                continue
        elif line.startswith('License: '):
            license_line = line
            continue
        elif license_line:
            if not license_line in used_licenses:
               print('update-copyright: warning: removing unused license ' + license_line[9:], file=sys.stderr)
               skip_body = True
            else:
               remainder.append(license_line)
            license_line = None
        if not skip_body:
            remainder.append(line)

    if errors:
        sys.exit(1)
    return '\n'.join(remainder) + '\n'


def write_output(known_patterns, data, attribution, output_file):
    if known_patterns:
        output_file.write('\n' + start_patterns + '\n')
        for copyright_info in known_patterns:
            for pattern in filter(lambda p: p.count > 0 or copyright_info.debian_copyright, copyright_info.patterns):
                copyright_info.files.append(pattern.path)
            if not copyright_info.files:
                if copyright_info.patterns[0].path != '*':
                    continue
                copyright_info.files.append('*')
            output_file.write('\n')
            output_file.write(format_list('Files: ', sorted(copyright_info.files)) + '\n')
            if copyright_info.files == ['debian/*']:
                 output_file.write(format_list('Copyright: ', copyright_info.debian_copyright) + '\n')
            else:
                 output_file.write(format_list('Copyright: ', copyright_info.get_strings(sorted(copyright_info.authors))) + '\n')
            output_file.write('License: ' + copyright_info.license + '\n')

    if data:
        output_file.write('\n' + start_overrides + '\n')
        for license in sorted(data.keys()):
            copyright_info = data[license]
            output_file.write('\n')
            output_file.write(format_list('Files: ', sorted(copyright_info.files)) + '\n')
            output_file.write(format_list('Copyright: ', copyright_info.get_strings(sorted(copyright_info.authors))) + '\n')
            output_file.write('License: ' + license + '\n')

    if attribution:
        output_file.write('\n' + start_attribution + '\n')
        for copyright_info in attribution:
            output_file.write('\n')
            output_file.write(format_list('Files: ', sorted(copyright_info.files)) + '\n')
            output_file.write(format_list('Copyright: ', copyright_info.authors) + '\n')
            output_file.write('License: ' + copyright_info.license + '\n')


if __name__ == '__main__':
    main('.')
